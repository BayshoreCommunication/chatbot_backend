name: ci-cd
on:
  push:
    branches: ["main"]

jobs:
  test:
    runs-on: ubuntu-22.04
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-python@v5
        with:
          python-version: "3.11"
      - name: Install dependencies
        run: |
          set -e
          python -m pip install --upgrade pip wheel setuptools
          REQS=""
          for f in requirements.txt app/requirements.txt; do
            if [ -f "$f" ]; then REQS="$f"; break; fi
          done
          if [ -z "$REQS" ]; then
            echo "No requirements.txt found (checked: ./requirements.txt and ./app/requirements.txt)"
            exit 1
          fi
          echo "Using $REQS"
          pip install -r "$REQS"
      - name: Syntax check
        run: |
          set -e
          echo "Checking Python syntax..."
          FILES=$(find . -name "*.py" -not -path "./.git/*" -not -path "./venv/*" -not -path "./env/*" -not -path "./__pycache__/*" | head -20)
          if [ -n "$FILES" ]; then
            echo "Found Python files:"
            echo "$FILES"
            python -m py_compile $FILES
            echo "âœ… All Python files compile successfully"
          else
            echo "No Python files found to check"
          fi

  deploy:
    needs: test
    runs-on: ubuntu-22.04
    steps:
      - uses: actions/checkout@v4

      - name: Trust SSH host
        run: |
          mkdir -p ~/.ssh
          ssh-keyscan -H ${{ secrets.SSH_HOST }} >> ~/.ssh/known_hosts

      - name: Emergency disk cleanup
        uses: appleboy/ssh-action@v1.2.0
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_KEY }}
          script: |
            echo "ğŸš¨ EMERGENCY DISK CLEANUP - Server is full!"
            echo "ğŸ“Š Disk usage before cleanup:"
            df -h

            echo "ğŸ§¹ Cleaning up everything possible..."

            # Stop Docker first (don't reload daemon yet)
            echo "ğŸ›‘ Stopping Docker service..."
            sudo systemctl stop docker 2>/dev/null || true
            sleep 3

            # Kill any remaining Docker processes
            sudo pkill -9 dockerd 2>/dev/null || true
            sudo pkill -9 docker-containerd 2>/dev/null || true
            sudo pkill -9 docker-containerd-shim 2>/dev/null || true
            sudo pkill -9 buildkitd 2>/dev/null || true
            sleep 2

            # Unmount any busy Docker filesystems
            echo "ğŸ”“ Unmounting Docker filesystems..."
            sudo umount /var/lib/docker/buildkit/executor/*/rootfs 2>/dev/null || true
            sudo umount /var/lib/docker/overlay2/*/merged 2>/dev/null || true
            for mount in $(mount | grep '/var/lib/docker' | awk '{print $3}' | tac); do
              sudo umount -fl "$mount" 2>/dev/null || true
            done
            sleep 3

            # Completely remove Docker's data directory to fix corruption
            echo "ğŸ—‘ï¸  Removing corrupted Docker data (this will fix overlay2 errors)..."
            sudo rm -rf /var/lib/docker/* 2>/dev/null || true
            sudo rm -rf /var/lib/docker/.* 2>/dev/null || true

            # Also clean buildkit cache separately
            echo "ğŸ—‘ï¸  Cleaning buildkit cache..."
            sudo rm -rf /var/lib/buildkit 2>/dev/null || true
            sudo rm -rf ~/.docker/buildx 2>/dev/null || true

            # Recreate Docker directories with proper structure
            echo "ğŸ“ Recreating Docker directories..."
            sudo mkdir -p /var/lib/docker/overlay2
            sudo mkdir -p /var/lib/docker/image
            sudo mkdir -p /var/lib/docker/volumes
            sudo mkdir -p /var/lib/docker/containers
            sudo mkdir -p /var/lib/docker/tmp
            sudo chmod -R 700 /var/lib/docker

            # Clean systemd runtime directories
            echo "ğŸ§¹ Cleaning systemd runtime..."
            sudo journalctl --vacuum-time=1h 2>/dev/null || true
            sudo journalctl --vacuum-size=10M 2>/dev/null || true
            sudo rm -rf /run/log/journal/* 2>/dev/null || true
            sudo rm -rf /var/log/journal/* 2>/dev/null || true

            # Clean /run/systemd/ specifically
            echo "ğŸ§¹ Cleaning /run/systemd/ directory..."
            sudo find /run/systemd/ -type f -name "*.timer" -delete 2>/dev/null || true
            sudo find /run/systemd/ -type f -name "*.service" -delete 2>/dev/null || true
            sudo rm -rf /run/systemd/transient/* 2>/dev/null || true
            sudo rm -rf /run/systemd/units/* 2>/dev/null || true

            echo "ğŸ“Š Space in /run/systemd/:"
            df -h /run/systemd/ || true
            du -sh /run/systemd/* 2>/dev/null | sort -hr | head -10 || true

            # Clean package cache
            sudo apt-get autoremove -y 2>/dev/null || true
            sudo apt-get autoclean 2>/dev/null || true
            sudo apt-get clean 2>/dev/null || true
            sudo rm -rf /var/cache/apt/archives/* 2>/dev/null || true
            sudo rm -rf /var/lib/apt/lists/* 2>/dev/null || true

            # Clean temporary files
            sudo rm -rf /tmp/* 2>/dev/null || true
            sudo rm -rf /var/tmp/* 2>/dev/null || true
            sudo rm -rf /var/log/*.log 2>/dev/null || true
            sudo rm -rf /var/log/*.gz 2>/dev/null || true

            # Clean old kernels
            sudo apt-get autoremove --purge -y 2>/dev/null || true

            # Clean home directory
            rm -rf ~/.cache/* 2>/dev/null || true
            rm -rf ~/.npm/* 2>/dev/null || true

            # Clean up any existing app directories
            sudo rm -rf /opt/chatbot-app 2>/dev/null || true
            sudo rm -rf /tmp/chatbot-app 2>/dev/null || true

            echo "ğŸ“Š Disk usage after cleanup:"
            df -h

            echo "ğŸ” Finding largest directories:"
            sudo du -h --max-depth=1 / 2>/dev/null | sort -hr | head -10 || true

            # Restart Docker with fresh filesystem
            echo "ğŸ³ Starting Docker with clean filesystem..."
            sudo systemctl start docker 2>/dev/null || true
            sleep 10

            # Verify Docker is working
            echo "âœ… Verifying Docker status..."
            timeout 30 bash -c 'until docker info >/dev/null 2>&1; do sleep 2; done' || {
              echo "âš ï¸  Docker not responding, trying restart..."
              sudo systemctl restart docker
              sleep 10
              timeout 30 bash -c 'until docker info >/dev/null 2>&1; do sleep 2; done' || {
                echo "âŒ Docker failed to start after restart"
                sudo journalctl -u docker -n 50 --no-pager
                exit 1
              }
            }

            docker info
            echo "âœ… Docker is running successfully"

            echo "ğŸ“Š Final disk usage:"
            df -h

      - name: Create app directory on server
        uses: appleboy/ssh-action@v1.2.0
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_KEY }}
          script: |
            echo "ğŸ“ Creating app directory..."
            echo "Target directory: ${{ secrets.APP_DIR }}"

            # Use permanent directory instead of /tmp
            APP_DIR="/opt/chatbot-app"
            echo "Using permanent directory: $APP_DIR"

            sudo mkdir -p $APP_DIR
            sudo chown -R ${{ secrets.SSH_USER }}:${{ secrets.SSH_USER }} $APP_DIR
            sudo chmod 755 $APP_DIR

            echo "âœ… Permanent directory created: $APP_DIR"
            echo "Current user: $(whoami)"
            echo "Directory permissions:"
            ls -la $APP_DIR
            echo "ğŸ“Š Available space:"
            df -h $APP_DIR

      - name: Clone repo on server
        uses: appleboy/ssh-action@v1.2.0
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_KEY }}
          script: |
            echo "ğŸ“¥ Cloning repository directly on server..."
            echo "Repository: ${{ github.server_url }}/${{ github.repository }}.git"

            # Use permanent directory
            APP_DIR="/opt/chatbot-app"
            echo "Target directory: $APP_DIR"

            # Remove existing directory if it exists
            sudo rm -rf $APP_DIR

            # Clone the repository
            git clone https://github.com/${{ github.repository }}.git $APP_DIR

            # Set proper ownership
            sudo chown -R ${{ secrets.SSH_USER }}:${{ secrets.SSH_USER }} $APP_DIR

            echo "âœ… Repository cloned successfully"
            echo "ğŸ“Š Disk usage after clone:"
            df -h

      - name: Verify clone and checkout latest
        uses: appleboy/ssh-action@v1.2.0
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_KEY }}
          script: |
            echo "ğŸ” Verifying repository clone..."
            APP_DIR="/opt/chatbot-app"
            cd $APP_DIR
            echo "Current directory: $(pwd)"
            echo "Git status:"
            git status
            echo "Latest commit:"
            git log --oneline -1
            echo "Files in directory:"
            ls -la
            echo "ğŸ“Š Disk usage after clone:"
            df -h

      - name: Build, restart, health check
        uses: appleboy/ssh-action@v1.2.0
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_KEY }}
          script: |
            set -e
            echo "ğŸš€ Starting deployment..."

            # Use a more permanent directory instead of /tmp
            APP_DIR="/opt/chatbot-app"
            echo "ğŸ“ Using permanent directory: $APP_DIR"

            # Create directory with proper permissions
            echo "Creating directory: $APP_DIR"
            sudo mkdir -p $APP_DIR
            sudo chown -R ${{ secrets.SSH_USER }}:${{ secrets.SSH_USER }} $APP_DIR
            sudo chmod 755 $APP_DIR

            # Change to directory and verify
            cd $APP_DIR
            echo "âœ… Current directory: $(pwd)"
            echo "ğŸ“‹ Directory contents:"
            ls -la
            echo "ğŸ“Š Directory permissions:"
            ls -ld $APP_DIR

            # Check if we have the application files
            if [ ! -f "main.py" ] || [ ! -f "requirements.txt" ] || [ ! -f "Dockerfile" ] || [ ! -f "docker-compose.yml" ]; then
              echo "âŒ Application files missing! Cloning repository..."
              sudo rm -rf $APP_DIR/*
              git clone https://github.com/${{ github.repository }}.git $APP_DIR
              sudo chown -R ${{ secrets.SSH_USER }}:${{ secrets.SSH_USER }} $APP_DIR
              echo "âœ… Repository cloned"
              ls -la
            else
              echo "âœ… Application files found"
            fi

            # Remove any .env file that might interfere with Docker environment variables
            echo "ğŸ§¹ Removing any .env file to ensure Docker environment variables are used..."
            rm -f .env || true

            # Double-check critical files exist
            echo "ğŸ” Verifying critical files..."
            echo "main.py exists: $([ -f "main.py" ] && echo "YES" || echo "NO")"
            echo "requirements.txt exists: $([ -f "requirements.txt" ] && echo "YES" || echo "NO")"
            echo "Dockerfile exists: $([ -f "Dockerfile" ] && echo "YES" || echo "NO")"
            echo "docker-compose.yml exists: $([ -f "docker-compose.yml" ] && echo "YES" || echo "NO")"

            # Show file permissions
            echo "ğŸ“‹ File permissions:"
            ls -la main.py requirements.txt Dockerfile docker-compose.yml 2>/dev/null || echo "Some files missing"

            # Start Docker service (avoid daemon reload to prevent disk space issues)
            echo "ğŸ³ Starting Docker service..."
            if ! sudo systemctl is-active --quiet docker; then
              sudo systemctl start docker 2>/dev/null || true
            fi

            # Do NOT enable Docker at boot if it causes daemon reload issues
            # sudo systemctl enable docker

            # Wait for Docker to be ready
            echo "â³ Waiting for Docker to be ready..."
            timeout 30 bash -c 'until docker info >/dev/null 2>&1; do sleep 1; done' || {
              echo "âŒ Docker failed to start, trying restart..."
              sudo systemctl restart docker 2>/dev/null || true
              sleep 5
              docker info >/dev/null 2>&1 || {
                echo "âŒ Docker still not running"
                sudo systemctl status docker
                exit 1
              }
            }

            echo "âœ… Docker is running"

            # Clean up disk space aggressively
            echo "ğŸ§¹ Cleaning up disk space..."
            sudo docker system prune -af --volumes || true
            sudo docker builder prune -af || true
            sudo apt-get autoremove -y || true
            sudo apt-get autoclean || true
            sudo apt-get clean || true
            sudo rm -rf /tmp/* || true
            sudo rm -rf /var/tmp/* || true
            echo "ğŸ“Š Disk usage before build:"
            df -h

            # Add current user to docker group (if not already added)
            echo "ğŸ‘¤ Adding user to docker group..."
            sudo usermod -aG docker $USER || true

            # Check if docker compose is available
            if docker compose version >/dev/null 2>&1; then 
              DC="docker compose"
            else 
              DC="docker-compose"
            fi

            echo "Using Docker Compose command: $DC"

            # Final verification before Docker commands
            echo "ğŸ” Final verification before Docker commands..."
            echo "Current directory: $(pwd)"
            echo "Directory contents:"
            ls -la
            echo "docker-compose.yml exists: $([ -f "docker-compose.yml" ] && echo "YES" || echo "NO")"

            if [ ! -f "docker-compose.yml" ]; then
              echo "âŒ docker-compose.yml missing! Re-cloning repository..."
              sudo rm -rf $APP_DIR/*
              git clone https://github.com/${{ github.repository }}.git $APP_DIR
              sudo chown -R ${{ secrets.SSH_USER }}:${{ secrets.SSH_USER }} $APP_DIR
              cd $APP_DIR
              echo "âœ… Repository re-cloned"
              ls -la
            fi

            # Set basic environment variables for docker-compose down
            export MONGO_URI="temp"
            export OPENAI_API_KEY="temp"
            export PINECONE_API_KEY="temp"
            export PINECONE_ENV="temp"
            export PINECONE_INDEX="temp"
            export DO_SPACES_BUCKET="temp"
            export DO_SPACES_REGION="temp"
            export DO_SPACES_KEY="temp"
            export DO_SPACES_SECRET="temp"
            export DO_FOLDER_NAME="temp"
            export GOOGLE_CLIENT_ID="temp"
            export GOOGLE_CLIENT_SECRET="temp"
            export JWT_SECRET_KEY="temp"
            export JWT_ALGORITHM="temp"
            export JWT_ACCESS_TOKEN_EXPIRE_MINUTES="temp"
            export REDIS_PASSWORD="temp"
            export CLIENT_ID="temp"
            export CLIENT_SECRE="temp"
            export WEBHOOK_SIGNING_KEY="temp"
            export CALENDLY_API_KEY="temp"
            export PUBLISHABLE_KEY="temp"
            export STRIPE_SECRET_KEY="temp"
            export STRIPE_WEBHOOK_SECRET="temp"

            # Stop existing containers and clean up ports
            echo "â¹ï¸ Stopping existing containers..."
            $DC down || true

            # First, stop any system web servers that might be using port 80/443
            echo "ğŸ›‘ Stopping system web servers..."
            sudo systemctl stop apache2 2>/dev/null || true
            sudo systemctl stop nginx 2>/dev/null || true
            sudo systemctl stop caddy 2>/dev/null || true
            sudo systemctl stop httpd 2>/dev/null || true

            # Kill any processes using ports 80, 443, 8000, 27017, 6379
            echo "ğŸ”Œ Checking for processes using ports 80, 443, 8000, 27017, 6379..."

            # Kill port 80 (HTTP)
            PORT_80_PID=$(sudo lsof -t -i:80 2>/dev/null || echo "")
            if [ ! -z "$PORT_80_PID" ]; then
              echo "Found process $PORT_80_PID using port 80, killing it..."
              sudo kill -9 $PORT_80_PID || true
              sleep 2
            fi

            # Kill port 443 (HTTPS)
            PORT_443_PID=$(sudo lsof -t -i:443 2>/dev/null || echo "")
            if [ ! -z "$PORT_443_PID" ]; then
              echo "Found process $PORT_443_PID using port 443, killing it..."
              sudo kill -9 $PORT_443_PID || true
              sleep 2
            fi

            # Kill port 8000
            PORT_PID=$(sudo lsof -t -i:8000 2>/dev/null || echo "")
            if [ ! -z "$PORT_PID" ]; then
              echo "Found process $PORT_PID using port 8000, killing it..."
              sudo kill -9 $PORT_PID || true
            fi

            # Kill port 27017 (MongoDB)
            MONGODB_PID=$(sudo lsof -t -i:27017 2>/dev/null || echo "")
            if [ ! -z "$MONGODB_PID" ]; then
              echo "Found process $MONGODB_PID using port 27017, killing it..."
              sudo kill -9 $MONGODB_PID || true
            fi

            # Kill port 6379 (Redis)
            REDIS_PID=$(sudo lsof -t -i:6379 2>/dev/null || echo "")
            if [ ! -z "$REDIS_PID" ]; then
              echo "Found process $REDIS_PID using port 6379, killing it..."
              sudo kill -9 $REDIS_PID || true
            fi

            # Stop any existing Redis/MongoDB services
            echo "ğŸ›‘ Stopping existing Redis and MongoDB services..."
            sudo systemctl stop redis-server 2>/dev/null || true
            sudo systemctl stop mongod 2>/dev/null || true
            sudo systemctl stop redis 2>/dev/null || true
            sudo systemctl stop mongodb 2>/dev/null || true

            sleep 3

            # Remove any existing containers with the same name
            echo "ğŸ—‘ï¸ Removing any existing chatbot-backend containers..."
            sudo docker rm -f chatbot-backend 2>/dev/null || true

            # Clean up any orphaned networks
            echo "ğŸ§¹ Cleaning up orphaned networks..."
            sudo docker network prune -f || true

            # Final port check before starting new containers
            echo "ğŸ” Final port availability check..."
            if sudo netstat -tlnp | grep -q ":80 "; then
              echo "âš ï¸  Port 80 still in use, forcing cleanup..."
              sudo fuser -k 80/tcp 2>/dev/null || true
              sleep 3
            fi
            if sudo netstat -tlnp | grep -q ":443 "; then
              echo "âš ï¸  Port 443 still in use, forcing cleanup..."
              sudo fuser -k 443/tcp 2>/dev/null || true
              sleep 3
            fi

            # Build new container
            echo "ğŸ—ï¸ Building new container..."
            echo "Current directory: $(pwd)"
            echo "Docker Compose file:"
            cat docker-compose.yml || echo "No docker-compose.yml found"

            # Reset Docker build cache to avoid corruption
            echo "ğŸ”„ Resetting Docker build cache..."
            sudo docker builder prune -af 2>/dev/null || true

            # Set environment variables from GitHub Secrets
            echo "ğŸ”§ Setting environment variables from secrets..."
            export MONGO_URI="${{ secrets.MONGO_URI }}"
            export OPENAI_API_KEY="${{ secrets.OPENAI_API_KEY }}"
            export PINECONE_API_KEY="${{ secrets.PINECONE_API_KEY }}"
            export PINECONE_ENV="${{ secrets.PINECONE_ENV }}"
            export PINECONE_INDEX="${{ secrets.PINECONE_INDEX }}"
            export DO_SPACES_BUCKET="${{ secrets.DO_SPACES_BUCKET }}"
            export DO_SPACES_REGION="${{ secrets.DO_SPACES_REGION }}"
            export DO_SPACES_KEY="${{ secrets.DO_SPACES_KEY }}"
            export DO_SPACES_SECRET="${{ secrets.DO_SPACES_SECRET }}"
            export DO_FOLDER_NAME="${{ secrets.DO_FOLDER_NAME }}"
            export GOOGLE_CLIENT_ID="${{ secrets.GOOGLE_CLIENT_ID }}"
            export GOOGLE_CLIENT_SECRET="${{ secrets.GOOGLE_CLIENT_SECRET }}"
            export JWT_SECRET_KEY="${{ secrets.JWT_SECRET_KEY }}"
            export JWT_ALGORITHM="${{ secrets.JWT_ALGORITHM }}"
            export JWT_ACCESS_TOKEN_EXPIRE_MINUTES="${{ secrets.JWT_ACCESS_TOKEN_EXPIRE_MINUTES }}"
            export REDIS_PASSWORD="${{ secrets.REDIS_PASSWORD }}"
            export CLIENT_ID="${{ secrets.CLIENT_ID }}"
            export CLIENT_SECRE="${{ secrets.CLIENT_SECRE }}"
            export WEBHOOK_SIGNING_KEY="${{ secrets.WEBHOOK_SIGNING_KEY }}"
            export CALENDLY_API_KEY="${{ secrets.CALENDLY_API_KEY }}"
            export PUBLISHABLE_KEY="${{ secrets.PUBLISHABLE_KEY }}"
            export STRIPE_SECRET_KEY="${{ secrets.STRIPE_SECRET_KEY }}"
            export STRIPE_WEBHOOK_SECRET="${{ secrets.STRIPE_WEBHOOK_SECRET }}"
            export SMPT_SERVICE="${{ secrets.SMPT_SERVICE }}"
            export SMPT_HOST="${{ secrets.SMPT_HOST }}"
            export SMPT_PORT="${{ secrets.SMPT_PORT }}"
            export SMPT_MAIL="${{ secrets.SMPT_MAIL }}"
            export SMPT_PASSWORD="${{ secrets.SMPT_PASSWORD }}"
            export FRONTEND_URL="${{ secrets.FRONTEND_URL }}"

            # Debug: Check if critical environment variables are set
            echo "ğŸ” Verifying environment variables..."
            echo "MONGO_URI length: ${#MONGO_URI}"
            echo "OPENAI_API_KEY length: ${#OPENAI_API_KEY}"
            echo "PINECONE_API_KEY length: ${#PINECONE_API_KEY}"

            if [ -z "$MONGO_URI" ]; then
              echo "âŒ MONGO_URI is empty! Check GitHub Secrets."
              exit 1
            fi

            # Build with no cache to avoid corrupted layers
            echo "ğŸ—ï¸  Building Docker images..."
            $DC build --no-cache --pull web || {
              echo "âŒ Docker build failed! Trying complete Docker reset..."
              
              # Stop Docker completely
              sudo systemctl stop docker
              sleep 3
              
              # Kill all Docker processes including buildkit
              sudo pkill -9 dockerd 2>/dev/null || true
              sudo pkill -9 buildkitd 2>/dev/null || true
              sudo pkill -9 docker-containerd 2>/dev/null || true
              sleep 2
              
              # Unmount all Docker filesystems forcefully
              echo "ğŸ”“ Force unmounting Docker filesystems..."
              for mount in $(mount | grep '/var/lib/docker' | awk '{print $3}'); do
                sudo umount -fl "$mount" 2>/dev/null || true
              done
              sleep 2
              
              # Remove everything again
              sudo rm -rf /var/lib/docker/*
              sudo mkdir -p /var/lib/docker
              
              # Restart Docker
              sudo systemctl start docker
              sleep 10
              
              # Wait for Docker to be ready
              timeout 60 bash -c 'until docker info >/dev/null 2>&1; do sleep 2; done' || {
                echo "âŒ Docker failed to start after reset"
                exit 1
              }
              
              echo "âœ… Docker reset complete, retrying build..."
              $DC build --no-cache --pull web || {
                echo "âŒ Build still failed after Docker reset"
                echo "ğŸ“‹ Docker logs:"
                sudo journalctl -u docker -n 50 --no-pager
                exit 1
              }
            }

            # Start containers
            echo "ğŸš€ Starting containers with DNS configuration..."
            $DC up -d --force-recreate

            # Wait for Redis to be ready (MongoDB is external via Atlas)
            echo "â³ Waiting for Redis to start..."
            sleep 10

            # Check if Redis is ready
            echo "ğŸ” Checking Redis status..."
            sudo docker exec chatbot-redis redis-cli ping || echo "Redis not ready yet"

            # Note: MongoDB connection is external via MongoDB Atlas
            echo "ğŸ“¡ Using external MongoDB Atlas connection"

            # Wait for web service to be ready
            echo "â³ Waiting for web service to start..."
            sleep 10

            # Verify containers are running
            echo "ğŸ” Checking container status..."
            sudo docker ps -a
            echo "ğŸ”Œ Checking port 8000..."
            sudo netstat -tlnp | grep :8000 || echo "Port 8000 not found in netstat"
            sudo lsof -i:8000 || echo "No process found using port 8000"

            # Health check
            echo "ğŸ¥ Running health check..."
            for i in {1..30}; do
              code=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:8000/ping || echo 000)
              echo "Health check attempt $i: HTTP $code"
              if [ "$code" = "200" ]; then
                echo "âœ… Health check passed!"
                break
              fi
              if [ $i -eq 30 ]; then
                echo "âŒ Health check failed after 30 attempts"
                echo "Container logs:"
                $DC logs --no-color --tail=50 web
                exit 1
              fi
              sleep 5
            done

            echo "ğŸ‰ Deployment completed successfully!"
            echo "Your app is running at: http://${{ secrets.SSH_HOST }}:8000"
